{
  "executive_summary": "Frederick P. Brooks Jr. (UNC Chapel Hill), in No Silver Bullet\u2014IFIP Tenth World Computing Conference; The Mythical Man-Month, Addison-Wesley Anniversary ed.\u2014argues no technology or management technique promises an order-of-magnitude productivity gain within a decade. Four essential properties\u2014Complexity, Conformity, Changeability, Invisibility\u2014are irreducible; three past breakthroughs (high-level languages, time-sharing, Unix/Interlisp) attacked only accidental difficulties, now exhausted. Proposed silver bullets\u2014Ada, OOP, expert systems, automatic programming, graphical programming, verification\u2014each fail; four promising directions are buying rather than building, rapid prototyping, incremental development (Harlan Mills), and cultivating great designers.",
  "core_thesis": "No single development in technology or management technique promises an order-of-magnitude improvement within a decade because the hard part of software\u2014specification, design, and testing of the conceptual construct\u2014is an essential difficulty inherent in the nature of software, not an accidental one that can be engineered away.",
  "main_arguments": [
    "Brooks distinguishes essential difficulties (inherent in the nature of software) from accidental difficulties (attending software production today but not inherent), and since accidental activities cannot represent more than 9/10 of all effort, shrinking them to zero cannot yield an order-of-magnitude improvement.",
    "Software entities are more complex for their size than perhaps any other human construct: no two parts are alike above the statement level, systems have orders of magnitude more states than computers, and scaling up necessarily increases the number of different elements\u2014making complexity an essential, not accidental, property whose abstraction also abstracts away the essence.",
    "Conformity is an essential difficulty because software must conform to arbitrary interfaces designed by different people, not by necessity or physical law, so much of the developer's complexity cannot be simplified out by any redesign of the software alone.",
    "Changeability is an essential difficulty because software embodies its system's function\u2014the part most subject to change pressures\u2014and because it is pure thought-stuff, infinitely malleable, all successful software gets changed; the software product is embedded in a cultural matrix of applications, users, laws, and machine vehicles that change continually.",
    "Invisibility is an essential difficulty because software has no ready geometric representation\u2014unlike land (maps), silicon chips (diagrams), or computers (connectivity schematics)\u2014its structure constituting several general directed graphs (control flow, data flow, dependency patterns, time sequence, name-space relationships) superimposed upon one another, usually not even planar, severely hindering design and communication among minds.",
    "Three major past breakthroughs each attacked only accidental difficulties: high-level languages yielded at least a factor-of-five in productivity by abstracting away bits, registers, branches, and channels; time-sharing preserved immediacy and maintained overview of complexity, with benefits ending once response time passes the human threshold of noticeability at about 100 milliseconds; and Unix and Interlisp\u2014the first integrated programming environments\u2014improved productivity by integral factors through integrated libraries, unified file formats, pipes and filters, and stimulated whole toolbenches.",
    "Ada embodies features for modern design and modularization; its philosophy of abstract data types, modularization, and hierarchical structuring represents more of an advance than the language itself; its greatest contribution will be training programmers in modern software design techniques; it is perhaps over-rich, but subset working vocabularies and cheap MIPS from hardware advances address its costs; it will not prove to be the silver bullet.",
    "Object-oriented programming holds more hope than any other technical fad of the day\u2014Brooks states he is among the believers\u2014offering abstract data types (defined by name, proper values, and proper operations, exemplified by Ada packages with private types and Modula's modules) and hierarchical types (exemplified by Simula-67's classes), as Mark Sherman of Dartmouth clarified; both remove accidental difficulty, but an order-of-magnitude gain could come only if unnecessary type specification were responsible for nine-tenths of the work\u2014which Brooks doubts.",
    "David L. Parnas defines AI-1 (using computers to solve problems previously requiring human intelligence) and AI-2 (heuristic or rule-based programming), clarifying terminological chaos; Brooks does not expect AI to provide a revolutionary breakthrough because most AI work is problem-specific and techniques for speech recognition, image recognition, and expert systems have little in common; however, expert systems\u2014generalized inference engines plus rule bases\u2014offer genuine promise, with Edward Feigenbaum noting their power comes from ever-richer knowledge bases, not ever-fancier inference mechanisms, with applications including suggesting interface rules, advising on testing strategies, remembering bug-type frequencies, and offering optimization hints.",
    "Automatic programming\u2014anticipated for almost 40 years\u2014is, per Parnas, always a euphemism for programming with a higher-level language than presently available, requiring specification of the solution method rather than the problem, and generalizes poorly; graphical programming has produced nothing convincing and Brooks is persuaded nothing will emerge since a VLSI chip's geometry reflects its essence while software's does not; program verification, while powerful for secure operating system kernels, cannot eliminate testing, cannot save labor (only a few substantial programs have ever been verified), and even a perfect proof only establishes that a program meets its specification\u2014not that the specification is complete or correct.",
    "The most radical possible solution for constructing software is not to construct it at all: any purchased piece of software at $100,000 costs about as much as one programmer-year, delivery is immediate, n copies effectively multiplies developer productivity by n, and the development of the mass market\u2014where 1950s\u201360s users refused off-the-shelf payroll/inventory/accounts-receivable packages while 1980s buyers demand them\u2014reflects changed hardware/software cost ratios, with electronic spreadsheets and simple database systems routing applications formerly written in Cobol or Report Program Generator.",
    "The hardest single part of building a software system is deciding precisely what to build; clients cannot specify completely, precisely, and correctly the exact requirements before building and trying versions; Harlan Mills proposed growing software by incremental development\u2014first running with dummy subprograms, then fleshed out top-down\u2014and nothing in the past decade has so radically changed Brooks's own practice or its effectiveness; teams can grow much more complex entities in four months than they can build, enthusiasm redoubles with first visible output, and great designers (rare as great managers) produce work approaching an order of magnitude better than average, as illustrated by exciting products of one or few minds (Unix, APL, Pascal, Modula, Smalltalk, Fortran) versus uninspiring committee products (Cobol, PL/I, Algol, MVS/370, MS-DOS)."
  ],
  "key_evidence": [
    "High-level languages provided at least a factor of five in productivity with concomitant gains in reliability, simplicity, and comprehensibility by abstracting away bits, registers, conditions, branches, channels, and disks\u2014with the biggest payoff coming from the first transition up from the accidental complexities of the machine.",
    "Time-sharing earned major improvement in programmer productivity and product quality\u2014though not as large as high-level languages\u2014by preserving immediacy and maintaining overview of complexity, with benefits ending once response time passes the human threshold of noticeability at about 100 milliseconds.",
    "Unix and Interlisp were the first integrated programming environments to come into widespread use, improving productivity by integral factors through integrated libraries, unified file formats, and pipes and filters, and stimulating development of whole toolbenches since each new tool could be applied to any programs using standard formats.",
    "No technology since civilization began has seen six orders of magnitude in price-performance gain in 30 years (hardware, through electronics, transistors, and large-scale integration); software cannot expect twofold gains every two years, making hardware progress the anomaly rather than software progress the failure.",
    "During the 1950s\u201360s, study after study showed users would not use off-the-shelf packages for payroll, inventory control, and accounts receivable; during the 1980s such packages are in high demand\u2014the shift reflecting changed hardware/software cost ratios, not the packages themselves, with buyers of $50,000 office machines unable to afford what buyers of $2-million machines in 1960 could, and electronic spreadsheets and simple database systems routing large numbers of applications formerly written in Cobol or Report Program Generator.",
    "Parnas states that 'automatic programming always has been a euphemism for programming with a higher-level language than was presently available to the programmer,' used for glamour rather than semantic meaning, and that in automatic programming it is the solution method, not the problem, whose specification must be given.",
    "Program verification is so much work that only a few substantial programs have ever been verified; even a perfect proof can only establish that a program meets its specification\u2014not that the specification is complete or correct\u2014and mathematical proofs can also be faulty, so the technology does not promise to save labor.",
    "The flow chart\u2014Burks, von Neumann, and Goldstine's attempt to provide a desperately needed high-level control language\u2014is a very poor abstraction of software structure, as evidenced by the fact that programmers draw flow charts after, not before, writing the programs they describe.",
    "A factor of 10 in machine speed would leave think-time the dominant activity; composition and editing of programs and documents is fully supported by today's speeds; language-specific smart editors promise freedom from syntactic errors and simple semantic errors, but the return must be marginal since the big-payoff problems have already been solved.",
    "Edward Feigenbaum holds that expert system power comes not from ever-fancier inference mechanisms but from ever-richer knowledge bases reflecting the real world more accurately; the gap between best and average software engineering practice is very wide\u2014perhaps wider than in any other engineering discipline\u2014making expert systems' potential to put the accumulated wisdom of the best programmers at the service of inexperienced programmers a significant prospect."
  ],
  "conclusions": [
    "Building software will always be hard\u2014there is inherently no silver bullet\u2014but addressing the essential parts concerned with fashioning abstract conceptual structures, combined with disciplined, consistent effort, should yield an order-of-magnitude improvement; there is no royal road, but there is a road.",
    "The development of the mass market\u2014buying rather than building, the most radical possible solution\u2014is the most profound long-run trend in software engineering, with n copies of a software system effectively multiplying its developers' productivity by n and shared costs radically cutting per-user cost.",
    "The most important function software builders perform for clients is the iterative extraction and refinement of product requirements; rapid prototyping as part of iterative specification is one of the most promising current technological efforts, attacking the essence of the software problem; and software acquisition procedures need fundamental revision providing for iterative development and specification of prototypes and products.",
    "Incremental development\u2014growing software organically as proposed by Harlan Mills, first made to run calling dummy subprograms then fleshed out top-down\u2014has radically changed Brooks's own practice and its effectiveness; teams can grow much more complex entities in four months than they can build, and enthusiasm redoubles with first visible output from a running system.",
    "Even a perfect program verification can only establish that a program meets its specification; arriving at a complete and consistent specification is the hardest part of the software task, and much of building a program is debugging that specification; program verification does not mean error-proof programs since mathematical proofs can also be faulty, and the technology does not promise to save labor.",
    "The most important single effort any software organization can mount is to develop ways to grow great designers\u2014with equivalent salary, recognition, perquisites, office size, furnishings, equipment, travel funds, and staff support as great managers\u2014by systematically identifying top designers early (often not the most experienced), assigning career mentors and maintaining career files, devising career development plans with apprenticeships, advanced education, and solo design assignments, and providing opportunities for growing designers to interact and stimulate each other.",
    "Ada's greatest contribution will be that switching to it occasions training programmers in modern software design techniques\u2014modularization, abstract data types, and hierarchical structuring\u2014with the philosophy mattering more than the language itself; Ada will not prove to be the silver bullet that slays the software productivity monster.",
    "Expert systems hold genuine promise not as a general silver bullet but as a vehicle for disseminating good practice by putting the accumulated wisdom of the best programmers at the service of inexperienced programmers, provided the essential prerequisite\u2014having an expert\u2014is met and efficient knowledge-acquisition techniques are developed from articulate, self-analytical experts."
  ]
}